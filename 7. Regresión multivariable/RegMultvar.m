clear
clc
tic
%%
data = readtable('auto-mpg.csv');
dataset = data(randperm(length(data.mpg)), :); % "Dataset" porque son los datos con los que trabajaremos

dataset.horsepower = fillmissing(dataset.horsepower(:), 'constant', nanmean(dataset.horsepower));

i = round(length(dataset.mpg)*0.75);

traindata = dataset(1:i, :);
testdata = dataset((i+1):end, :);

i = length(dataset.cylinders);
D1 = ones(i, 1);

X = [traindata.mpg traindata.displacement traindata.horsepower traindata.weight traindata.acceleration traindata.model_year traindata.origin]; % traindata.horsepower de tercero
X2 = [testdata.mpg testdata.displacement testdata.horsepower testdata.weight testdata.acceleration testdata.model_year testdata.origin]; % testdata.horsepower de tercero
r = traindata.cylinders;
r2 = testdata.cylinders;


%% Implementación de LDA

[fcyl Ncyl] = hist(traindata.cylinders, min(traindata.cylinders):1:max(traindata.cylinders));
% Si = 0;
Sw = 0;
Sb = 0;
[a, b] = size(X);
mcent = nan(length(Ncyl(fcyl~=0)), b);

for i = Ncyl(fcyl~=0)
    ind = find(Ncyl==i);
    Xi = X(traindata.cylinders(:)==i,:);
    mi = mean(Xi);
    Si = i*(X-mi)'*(X-mi);
    Sw = Sw + Si;
    i;
    
    mcent(ind, :) = mi;  
end

mt = mean(mcent, 'omitnan');

for i = Ncyl(fcyl~=0)
    ind = find(Ncyl==i);

    Xi = X(traindata.cylinders(:)==i,:);
    mi = mean(Xi);

    Sj = fcyl(ind)*(mi-mt)'*(mi-mt);
    Sb = Sb + Sj;
end

Sw;
Sb;

[V D] = eig(inv(Sw)*Sb);

cant = length(find(D>max(D, [], 'all')/1000)) %% El diez es la división al valor máximo de la matriz para asumir los menores a max/10 como cero.
[M I] = maxk(sum(D), cant);
Wlda = V(:,I)

%%
Zlda = [ones(length(traindata.cylinders), 1) X*Wlda];
Z2lda = [ones(length(testdata.cylinders), 1) X2*Wlda];

w = inv(Zlda'*Zlda)*Zlda'*r;
cylinderML = round(Z2lda*w);

aciertosLDA = sum(cylinderML==testdata.cylinders)/length(testdata.cylinders)
MSE_LDA_Reg = mean((cylinderML-testdata.cylinders).^2)
R_LDA = corr2(cylinderML, testdata.cylinders)

%%
Zlda(:, 1) = [];
Z2lda(:, 1) = [];

k=1;
for i = 1:length(testdata.mpg)
    i;
    d = ((Z2lda(i,:) - Zlda).^2);
    d = sqrt(d(:,1)+d(:,2));
    
    [dis, pos] = mink(d, k);
    cylinderML2(i,1) = mode(traindata.cylinders(pos));
end

kNNlda = sum(cylinderML2==testdata.cylinders(:))/length(testdata.cylinders)
% MSE_LDA = mean((cylinderML3-testdata.cylinders(:)).^2)
% R2_LDA = corr2(cylinderML3, testdata.cylinders)

toc

%% Red Neuronal para predicción de cylinders.

% Solve an Input-Output Fitting problem with a Neural Network
% Script generated by Neural Fitting app
% Created 03-Apr-2022 21:05:14
%
% This script assumes these variables are defined:
%
%   X - input data.
%   r - target data.

x = X';
t = r';

% Choose a Training Function
% For a list of all training functions type: help nntrain
% 'trainlm' is usually fastest.
% 'trainbr' takes longer but may be better for challenging problems.
% 'trainscg' uses less memory. Suitable in low memory situations.
trainFcn = 'trainlm';  % Levenberg-Marquardt backpropagation.

% Create a Fitting Network
hiddenLayerSize = cant;
net = fitnet(hiddenLayerSize,trainFcn);

% Choose Input and Output Pre/Post-Processing Functions
% For a list of all processing functions type: help nnprocess
net.input.processFcns = {'removeconstantrows','mapminmax'};
net.output.processFcns = {'removeconstantrows','mapminmax'};

% Setup Division of Data for Training, Validation, Testing
% For a list of all data division functions type: help nndivision
net.divideFcn = 'dividerand';  % Divide data randomly
net.divideMode = 'sample';  % Divide up every sample
net.divideParam.trainRatio = 100/100;
net.divideParam.valRatio = 0/100;
net.divideParam.testRatio = 0/100;

% Choose a Performance Function
% For a list of all performance functions type: help nnperformance
net.performFcn = 'mse';  % Mean Squared Error

% Choose Plot Functions
% For a list of all plot functions type: help nnplot
net.plotFcns = {'plotperform','plottrainstate','ploterrhist', ...
    'plotregression', 'plotfit'};

% Train the Network
[net,tr] = train(net,x,t); %, 'useParallel', 'yes', 'useGPU', 'yes');

% Test the Network
y = net(x);
e = gsubtract(t,y);
performance = perform(net,t,y);

% Recalculate Training, Validation and Test Performance
trainTargets = t .* tr.trainMask{1};
valTargets = t .* tr.valMask{1};
testTargets = t .* tr.testMask{1};
trainPerformance = perform(net,trainTargets,y);
valPerformance = perform(net,valTargets,y);
testPerformance = perform(net,testTargets,y);

% View the Network
view(net);

% Deployment
% Change the (false) values to (true) to enable the following code blocks.
% See the help for each generation function for more information.
if (true)
    % Generate MATLAB function for neural network for application
    % deployment in MATLAB scripts or with MATLAB Compiler and Builder
    % tools, or simply to examine the calculations your trained neural
    % network performs.
    genFunction(net,'myNeuralNetworkFunction');
    y = myNeuralNetworkFunction(x);
end
if (false)
    % Generate a matrix-only MATLAB function for neural network code
    % generation with MATLAB Coder tools.
    genFunction(net,'myNeuralNetworkFunction','MatrixOnly','yes');
    y = myNeuralNetworkFunction(x);
end
if (false)
    % Generate a Simulink diagram for simulation or deployment with.
    % Simulink Coder tools.
    gensim(net);
end

%% Comprobación para Neural Network como predictor

cylinderML3 = round(myNeuralNetworkFunction(X2')');
aciertosLDA_NN = sum(cylinderML3==testdata.cylinders)/length(testdata.cylinders)

MSE_LDA_NN = mean((cylinderML3-testdata.cylinders(:)).^2)
R_LDA_NN = corr2(cylinderML3, testdata.cylinders)

%%
net.IW{1}';
net.b{1}';

net.LW{2}';
net.b{2}';

%%
% net.IW{1}', Wlda, net.LW{2}', w_NN, w, net.b{1}, net.B{2};

toc


%% PCA
%
%
%
%

tic

dataset;

X_tout = [dataset.mpg dataset.cylinders dataset.displacement dataset.horsepower dataset.weight dataset.acceleration dataset.model_year dataset.origin]; % traindata.horsepower de tercero

r = traindata.cylinders;

m = mean(X_tout);

[V D] = eig(cov(X_tout));

Des = sum(D, 'all');
cant = 0;
posi = sum(D);
Eigenes = 0;
while Eigenes<=0.9 %% Ch6, Diapo 11
    cant = cant + 1;
    Eigenes = sum(posi(end-cant:end))/Des;
end
cant;

[M I] = maxk(sum(D), cant+1);
Wpca = V(:,I);

Zpca = X_tout*Wpca;
X_f = Zpca*Wpca';

MS_PCA = mean((X_tout-X_f).^2 )

%%

netEncoded = trainAutoencoder(X_tout', cant+1, 'EncoderTransferFunction', ...
    'satlin', 'DecoderTransferFunction', 'purelin');
generateFunction(netEncoded, 'NNEnc');

X_fNN = NNEnc(X_tout')';

MS_NN = mean((X_tout-X_fNN).^2)

toc